#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=mesh/scripts/libmesh.sh
source "$SCRIPT_DIR/libmesh.sh"

ROOT_PATH="mesh"
ARCHITECTURE_MAP_PATH="viralForge/specs/service-architecture-map.yaml"
DEPENDENCIES_PATH="viralForge/specs/dependencies.yaml"
DEPLOYMENT_PROFILE_PATH="viralForge/specs/service-deployment-profile.md"
CHECK_MODE="0"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --root-path) ROOT_PATH="$2"; shift 2 ;;
    --architecture-map-path) ARCHITECTURE_MAP_PATH="$2"; shift 2 ;;
    --dependencies-path) DEPENDENCIES_PATH="$2"; shift 2 ;;
    --deployment-profile-path) DEPLOYMENT_PROFILE_PATH="$2"; shift 2 ;;
    --check) CHECK_MODE="1"; shift ;;
    *)
      echo "Unknown argument: $1" >&2
      exit 1
      ;;
  esac
done

mkdir -p "$ROOT_PATH/services" "$ROOT_PATH/docs"
ROOT_ABS="$(cd "$ROOT_PATH" && pwd)"

load_microservices "$ARCHITECTURE_MAP_PATH"
load_dependencies "$DEPENDENCIES_PATH"
load_categories_from_profile "$DEPLOYMENT_PROFILE_PATH"
load_suggested_clusters_from_profile "$DEPLOYMENT_PROFILE_PATH"
build_clustered_maps

declare -A IS_MICRO=()
declare -A IN_DEGREE=()
declare -A ADJ=()
svc=""
for svc in "${SERVICES[@]}"; do
  IS_MICRO["$svc"]="1"
  IN_DEGREE["$svc"]=0
  ADJ["$svc"]=""
done

for svc in "${SERVICES[@]}"; do
  dep=""
  while IFS= read -r dep; do
    [[ -z "$dep" ]] && continue
    if [[ -n "${IS_MICRO[$dep]-}" ]]; then
      append_map_line ADJ "$dep" "$svc"
      IN_DEGREE["$svc"]=$((IN_DEGREE["$svc"] + 1))
    fi
  done <<< "$(map_sorted_unique DEP_DBR "$svc")"
done

queue=()
for svc in "${SERVICES[@]}"; do
  if [[ "${IN_DEGREE[$svc]}" -eq 0 ]]; then
    queue+=("$svc")
  fi
done
if ((${#queue[@]} > 0)); then
  mapfile -t queue < <(printf '%s\n' "${queue[@]}" | LC_ALL=C sort -u)
fi

declare -a LEVELS=()
processed=0
while ((${#queue[@]} > 0)); do
  level_block="$(printf '%s\n' "${queue[@]}" | LC_ALL=C sort -u)"
  LEVELS+=("$level_block")
  next_block=""
  node=""
  for node in "${queue[@]}"; do
    processed=$((processed + 1))
    child=""
    while IFS= read -r child; do
      [[ -z "$child" ]] && continue
      IN_DEGREE["$child"]=$((IN_DEGREE["$child"] - 1))
      if [[ "${IN_DEGREE[$child]}" -eq 0 ]]; then
        next_block+="$child"$'\n'
      fi
    done <<< "$(map_sorted_unique ADJ "$node")"
  done
  mapfile -t queue < <(sorted_unique_block "$next_block")
done

if [[ "$processed" -ne "${#SERVICES[@]}" ]]; then
  cycle_block=""
  for svc in "${SERVICES[@]}"; do
    if [[ "${IN_DEGREE[$svc]}" -gt 0 ]]; then
      cycle_block+="$svc"$'\n'
    fi
  done
  cycle_csv="$(csv_from_block "$(sorted_unique_block "$cycle_block")")"
  echo "DBR cycle detected in microservice graph: $cycle_csv" >&2
  exit 1
fi

tmp_index="$(mktemp)"
tmp_load="$(mktemp)"
trap 'rm -f "$tmp_index" "$tmp_load"' EXIT

{
  echo "version: 1"
  echo "generated_by: mesh/scripts/generate-mesh-index.sh"
  echo "services:"
  for svc in "${SERVICES[@]}"; do
    dbr_block="$(map_sorted_unique DEP_DBR "$svc")"
    event_dep_block="$(map_sorted_unique DEP_EVENT_DEPS "$svc")"

    provides_collect=""
    if [[ "${DEP_HTTP[$svc]-0}" == "1" ]]; then
      provides_collect+="http"$'\n'
    fi
    evt=""
    while IFS= read -r evt; do
      [[ -z "$evt" ]] && continue
      provides_collect+="EVENT:$evt"$'\n'
    done <<< "$(map_sorted_unique DEP_EVENT_PROVIDES "$svc")"
    provides_block="$(sorted_unique_block "$provides_collect")"

    echo "  - service_id: $svc"
    echo "    architecture: microservice"
    echo "    cluster: ${SVC_CLUSTER[$svc]}"
    echo "    module_path: mesh/services/${SVC_CLUSTER[$svc]}/${SVC_DIR[$svc]}"
    echo "    dbr_deps:"
    emit_yaml_list "      " "$dbr_block"
    echo "    event_deps:"
    emit_yaml_list "      " "$event_dep_block"
    echo "    provides:"
    emit_yaml_list "      " "$provides_block"
  done
} > "$tmp_index"

tier0_block=""
tier1_block=""
tier2_block=""
for svc in "${SERVICES[@]}"; do
  cluster="${SVC_CLUSTER[$svc]}"
  if [[ "$cluster" == "platform-ops" ]]; then
    tier0_block+="$svc"$'\n'
  elif [[ "$cluster" == "core-platform" ]]; then
    tier1_block+="$svc"$'\n'
  else
    tier2_block+="$svc"$'\n'
  fi
done
tier0_csv="$(csv_from_block "$(sorted_unique_block "$tier0_block")")"
tier1_csv="$(csv_from_block "$(sorted_unique_block "$tier1_block")")"
tier2_csv="$(csv_from_block "$(sorted_unique_block "$tier2_block")")"

{
  echo "# Mesh Dependency Load Order"
  echo
  echo "Generated by: mesh/scripts/generate-mesh-index.sh"
  echo
  echo "## Summary"
  echo
  echo "- Total microservices: ${#SERVICES[@]}"
  echo "- DBR cycles detected: 0"
  echo
  echo "## DBR Topological Levels"
  echo
  level_num=0
  for level_block in "${LEVELS[@]}"; do
    echo "### Level $level_num"
    line=""
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      echo "- $line"
    done <<< "$level_block"
    echo
    level_num=$((level_num + 1))
  done

  echo "## Startup Tiers"
  echo
  echo "- tier0 (platform-ops): $tier0_csv"
  echo "- tier1 (core-platform): $tier1_csv"
  echo "- tier2 (domain clusters): $tier2_csv"
  echo
  echo "## DBR Matrix (Microservice -> Microservice)"
  echo
  echo "| Service | DBR Dependencies (microservice only) | Count |"
  echo "|---|---|---:|"
  for svc in "${SERVICES[@]}"; do
    micro_dbr=""
    d=""
    while IFS= read -r d; do
      [[ -z "$d" ]] && continue
      if [[ -n "${IS_MICRO[$d]-}" ]]; then
        micro_dbr+="$d"$'\n'
      fi
    done <<< "$(map_sorted_unique DEP_DBR "$svc")"
    micro_dbr_sorted="$(sorted_unique_block "$micro_dbr")"
    dep_count=0
    if [[ -n "$micro_dbr_sorted" ]]; then
      dep_count="$(printf '%s\n' "$micro_dbr_sorted" | sed '/^$/d' | wc -l | tr -d ' ')"
      dep_list="$(csv_from_block "$micro_dbr_sorted")"
    else
      dep_list="none"
    fi
    echo "| $svc | $dep_list | $dep_count |"
  done
  echo
  echo "## Boundary Rule"
  echo
  echo "- Service startup order does not permit direct cross-service writes or implicit DB access outside declared contracts."
  echo "- DBR dependencies are resolved via owner API/event projection patterns per canonical data ownership constraints."
} > "$tmp_load"

index_path="$ROOT_PATH/services/services-index.yaml"
load_order_path="$ROOT_PATH/docs/dependency-load-order.md"

if [[ "$CHECK_MODE" == "1" ]]; then
  errors=()
  if [[ ! -f "$index_path" ]]; then
    errors+=("Missing generated file: $ROOT_ABS/services/services-index.yaml")
  elif ! cmp -s "$tmp_index" "$index_path"; then
    errors+=("Out-of-date generated file: $ROOT_ABS/services/services-index.yaml")
  fi

  if [[ ! -f "$load_order_path" ]]; then
    errors+=("Missing generated file: $ROOT_ABS/docs/dependency-load-order.md")
  elif ! cmp -s "$tmp_load" "$load_order_path"; then
    errors+=("Out-of-date generated file: $ROOT_ABS/docs/dependency-load-order.md")
  fi

  if ((${#errors[@]} > 0)); then
    err=""
    for err in "${errors[@]}"; do
      echo "$err" >&2
    done
    exit 1
  fi
  echo "generate-mesh-index: check passed"
  exit 0
fi

mkdir -p "$(dirname "$index_path")" "$(dirname "$load_order_path")"
cp "$tmp_index" "$index_path"
cp "$tmp_load" "$load_order_path"
echo "generate-mesh-index: wrote $ROOT_ABS/services/services-index.yaml and $ROOT_ABS/docs/dependency-load-order.md"
